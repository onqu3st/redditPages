<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reddit Hustle Project v1.0</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'reddit-orange': '#FF4500',
            'reddit-orange-dark': '#cc3700',
            'hustle-accent': '#8a6cff',
            'hustle-accent-dark': '#6a4dff',
            'dark-bg': '#0f0f0f',
            'card-bg': '#1a1a1a',
            'text-muted': '#b3b3b3',
            'growth-green': '#4caf50',
          }
        }
      }
    }
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0f0f0f;
      --card-bg: #1a1a1a;
      --card-border: #333;
      --text-primary: #fff;
      --text-secondary: #b3b3b3;
      --highlight-primary: #8a6cff;
      --highlight-secondary: #ff6b6b;
      --border-color: #333;
      --card-glow-color: rgba(138, 108, 255, 0.3);
      --text-glow-color: rgba(138, 108, 255, 0.5);
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      --radius: 16px;
    }

    body {
      background: linear-gradient(135deg, #0f0f0f, #1a1a2e);
      color: var(--text-primary);
      font-family: 'Ubuntu', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* Glassmorphism Wavy Background - Optimized */
    body::before,
    body::after {
      content: "";
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      z-index: 0;
      will-change: transform;
    }

    body::before {
      background: radial-gradient(ellipse at center, rgba(44, 83, 100, 0.15) 0%, rgba(18, 32, 39, 0) 70%);
    }

    body::after {
      background:
        radial-gradient(ellipse at 30% 40%, rgba(138, 108, 255, 0.1) 0%, transparent 25%),
        radial-gradient(ellipse at 70% 60%, rgba(255, 107, 107, 0.08) 0%, transparent 25%),
        radial-gradient(ellipse at 50% 30%, rgba(138, 108, 255, 0.07) 0%, transparent 30%),
        radial-gradient(ellipse at 20% 80%, rgba(255, 107, 107, 0.05) 0%, transparent 30%);
      animation: wavyFlow 25s ease-in-out infinite alternate;
      filter: blur(40px);
      opacity: 0.7;
    }

    @media (prefers-reduced-motion: reduce) {
      body::after {
        animation: none;
      }
    }

    @keyframes wavyFlow {
      0%, 100% {
        transform: translate(0, 0) scale(1);
        background-position: 30% 40%, 70% 60%, 50% 30%, 20% 80%;
        background-size: 60% 60%, 50% 50%, 70% 70%, 65% 65%;
      }
      25% {
        transform: translate(-1%, 0.5%) scale(1.01);
        background-position: 32% 38%, 68% 62%, 48% 32%, 22% 78%;
        background-size: 62% 58%, 48% 52%, 68% 72%, 63% 67%;
      }
      50% {
        transform: translate(0.5%, -1%) scale(0.995);
        background-position: 28% 42%, 72% 58%, 52% 28%, 18% 82%;
        background-size: 58% 62%, 52% 48%, 72% 68%, 67% 63%;
      }
      75% {
        transform: translate(-0.5%, 0.8%) scale(1.005);
        background-position: 31% 39%, 69% 61%, 49% 31%, 21% 79%;
        background-size: 61% 59%, 49% 51%, 69% 71%, 64% 66%;
      }
    }

    .content-wrapper {
      position: relative;
      z-index: 10;
      padding: 2rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Enhanced Search and Filter Bar */
    .filter-bar {
      background: rgba(26, 26, 26, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid var(--card-border);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-bottom: 2rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      position: sticky;
      top: 1rem;
      z-index: 100;
    }

    .search-input {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 0.75rem 1rem;
      font-size: 14px;
      min-width: 250px;
      flex: 1;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--highlight-primary);
      box-shadow: 0 0 0 2px rgba(138, 108, 255, 0.2);
    }

    .filter-select {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 0.75rem;
      font-size: 14px;
      cursor: pointer;
    }

    .filter-select:focus {
      outline: none;
      border-color: var(--highlight-primary);
    }

    .filter-chip {
      background: var(--highlight-primary);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .filter-chip:hover {
      background: var(--highlight-secondary);
    }

    .filter-chip .remove {
      font-size: 16px;
      font-weight: bold;
    }

    .stats-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      font-size: 14px;
      color: var(--text-secondary);
    }

    /* Enhanced Card Styles */
    .page-card-container {
      width: 100%;
      perspective: 1000px;
      will-change: transform;
    }

    .page-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: 100%;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.3s ease;
      transform-style: preserve-3d;
      position: relative;
      outline: none;
      display: block;
      height: 100%;
      will-change: transform;
    }

    .page-card .media {
      height: 160px;
      background: conic-gradient(from 45deg, var(--highlight-primary), var(--highlight-secondary), #4ecdc4, var(--highlight-primary));
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    .page-card .media::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, transparent 40%, var(--card-bg) 90%);
    }

    .page-card .media span {
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0, 0, 0, .5);
      z-index: 1;
      text-align: center;
      padding: 0 1rem;
    }

    .page-card .content {
      padding: 20px;
    }

    .page-card .title {
      font-size: 20px;
      font-weight: 800;
      margin-bottom: 8px;
      background: linear-gradient(90deg, var(--highlight-primary), var(--highlight-secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      line-height: 1.3;
    }

    .page-card .desc {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 16px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .page-card .meta-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .page-card .dates {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .page-card .income-badge {
      background: rgba(76, 175, 80, 0.2);
      color: #4caf50;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    .page-card .footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .page-card .category-badge {
      background: var(--highlight-primary);
      color: #fff;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 11px;
      font-weight: 600;
    }

    .page-card .subreddit-badge {
      background: rgba(255, 69, 0, 0.2);
      color: #ff4500;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
    }

    /* Loading States */
    .card-skeleton {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: var(--radius);
      height: 400px;
      position: relative;
      overflow: hidden;
    }

    .card-skeleton::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: skeleton-loading 1.5s infinite;
    }

    @keyframes skeleton-loading {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    #pages-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .empty-state {
      grid-column: 1 / -1;
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-secondary);
    }

    .empty-state h3 {
      color: var(--text-primary);
      margin-bottom: 1rem;
    }

    @media (max-width: 768px) {
      .filter-bar {
        flex-direction: column;
        align-items: stretch;
      }
      
      .search-input {
        min-width: auto;
      }
      
      #pages-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Sync button and header styles remain the same */
    .sync-button {
      background: linear-gradient(90deg, var(--highlight-primary), var(--highlight-secondary));
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease, transform 0.1s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .sync-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(138, 108, 255, 0.3);
    }

    header h1 {
      background: linear-gradient(to right, var(--highlight-secondary), var(--highlight-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;
      animation: shimmer 3s infinite;
      text-shadow: 0 0 15px var(--text-glow-color);
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    footer {
      border-top: 1px solid var(--border-color);
      margin-top: 2rem;
      padding-top: 1rem;
    }
  </style>
</head>
<body class="antialiased">
  <div class="content-wrapper">
    <header class="text-center mb-8 pt-4">
      <h1 class="text-4xl md:text-5xl font-bold">Reddit Hustle Project</h1>
      <p class="text-lg mt-2 text-muted">The Grind Never Stops.</p>
      <div class="mt-6">
        <button id="sync-button" class="sync-button font-bold text-lg">
          Sync Sheets
        </button>
      </div>
    </header>

    <!-- Enhanced Filter Bar -->
    <div class="filter-bar" id="filter-bar" style="display: none;">
      <input 
        type="text" 
        id="search-input" 
        class="search-input" 
        placeholder="Search by title, description, or tags..."
      >
      
      <select id="sort-select" class="filter-select">
        <option value="newest">Newest First</option>
        <option value="oldest">Oldest First</option>
        <option value="income-high">Highest Income</option>
        <option value="income-low">Lowest Income</option>
        <option value="title">Alphabetical</option>
      </select>
      
      <select id="category-filter" class="filter-select">
        <option value="">All Categories</option>
      </select>
      
      <select id="subreddit-filter" class="filter-select">
        <option value="">All Subreddits</option>
      </select>
      
      <button id="clear-filters" class="filter-chip" style="background: var(--highlight-secondary);">
        Clear All
      </button>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar" id="stats-bar" style="display: none;">
      <span id="results-count">0 results</span>
      <span id="active-filters"></span>
    </div>

    <main id="pages-grid">
      <div id="initial-prompt" class="text-center text-muted py-10 col-span-full">
        <p>Click the <span class="highlight">Sync Sheets</span> button to load content from the repository.</p>
      </div>
    </main>

    <footer class="text-center py-6 text-sm text-muted">
      <p>&copy; 2025 Blayze_Quest</p>
    </footer>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const GITHUB_REPO = 'onqu3st/redditPages';
      const PAGES_DIR_API = `https://api.github.com/repos/${GITHUB_REPO}/contents/html`;

      // DOM elements
      const grid = document.getElementById('pages-grid');
      const syncButton = document.getElementById('sync-button');
      const filterBar = document.getElementById('filter-bar');
      const statsBar = document.getElementById('stats-bar');
      const searchInput = document.getElementById('search-input');
      const sortSelect = document.getElementById('sort-select');
      const categoryFilter = document.getElementById('category-filter');
      const subredditFilter = document.getElementById('subreddit-filter');
      const clearFiltersBtn = document.getElementById('clear-filters');
      const resultsCount = document.getElementById('results-count');
      const activeFilters = document.getElementById('active-filters');

      // State
      let allPages = [];
      let filteredPages = [];
      let pagesLoaded = false;
      let currentFilters = {
        search: '',
        sort: 'newest',
        category: '',
        subreddit: ''
      };

      // Performance optimization: Debounce search
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Extract metadata from HTML content
      function extractMetadata(htmlContent, filename) {
        const metadata = {
          title: formatTitle(filename),
          category: '',
          subreddit: '',
          income: '',
          description: '',
          addedDate: new Date(), // Current date as fallback
          postedDate: null
        };

        // Extract category from filename
        const categoryMatch = filename.match(/\[(.*?)\]/);
        if (categoryMatch) {
          metadata.category = categoryMatch[1];
        }

        // Extract subreddit from media span or content
        const subredditMatch = htmlContent.match(/<span[^>]*>r\/(.*?)<\/span>/) || 
                              htmlContent.match(/subreddit: r\/(.*?)[<\s]/i);
        if (subredditMatch) {
          metadata.subreddit = subredditMatch[1].trim();
        }

        // Extract income from chips or content
        const incomeMatch = htmlContent.match(/income[^>]*>([^<]*)/i) || 
                           htmlContent.match(/\$([0-9,]+(?:\.[0-9]{2})?)\/?(month|mo|year|yr)?/i);
        if (incomeMatch) {
          metadata.income = incomeMatch[0].replace(/income[^>]*>/i, '').trim();
        }

        // Extract description from first paragraph
        const descMatch = htmlContent.match(/<p class="desc"[^>]*>(.*?)<\/p>/i) ||
                         htmlContent.match(/<p[^>]*>(.*?)<\/p>/i);
        if (descMatch) {
          let desc = descMatch[1].replace(/<[^>]*>/g, '').trim();
          metadata.description = desc.length > 160 ? desc.substring(0, 157) + '...' : desc;
        } else {
          metadata.description = "Click to view detailed content.";
        }

        // Try to extract dates from content
        const dateMatch = htmlContent.match(/Posted: ([^<]*)/i) ||
                         htmlContent.match(/([0-9]{4}-[0-9]{2}-[0-9]{2})/i);
        if (dateMatch) {
          try {
            metadata.postedDate = new Date(dateMatch[1].trim());
          } catch (e) {
            metadata.postedDate = null;
          }
        }

        return metadata;
      }

      function formatTitle(filename) {
        return filename
          .replace('.html', '')
          .replace(/\[(.*?)\]/g, (m, p1) => `${p1.toUpperCase()}: `)
          .replace(/-/g, ' ')
          .replace(/_/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
      }

      function formatDate(date) {
        if (!date || isNaN(date.getTime())) return 'Unknown';
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          year: 'numeric' 
        });
      }

      function getRelativeTime(date) {
        if (!date || isNaN(date.getTime())) return 'Unknown';
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return '1 day ago';
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
      }

      async function createPageCard(pageData) {
        const { title, category, subreddit, income, description, addedDate, postedDate } = pageData.metadata;
        const pageUrl = `https://onqu3st.github.io/redditPages/html/${pageData.name}`;
        
        const categoryBadge = category ? `<span class="category-badge">${category}</span>` : '';
        const subredditBadge = subreddit ? `<span class="subreddit-badge">r/${subreddit}</span>` : '';
        const incomeBadge = income ? `<span class="income-badge">${income}</span>` : '';
        
        return `
          <div class="page-card-container" data-category="${category}" data-subreddit="${subreddit}">
            <a href="${pageUrl}" target="_blank" rel="noopener noreferrer" class="page-card no-underline block h-full">
              <div class="media">
                <span>${subreddit ? `r/${subreddit}` : (category || title.split(':')[0] || title)}</span>
              </div>
              <div class="content">
                <h3 class="title">${title}</h3>
                <p class="desc">${description}</p>
                
                <div class="meta-info">
                  <div class="dates">
                    <div>Added: ${formatDate(addedDate)}</div>
                    ${postedDate ? `<div>Posted: ${getRelativeTime(postedDate)}</div>` : ''}
                  </div>
                  ${incomeBadge}
                </div>
                
                <div class="footer">
                  <div style="display: flex; gap: 0.5rem; align-items: center;">
                    ${categoryBadge}
                    ${subredditBadge}
                  </div>
                  <div class="badge">View Details</div>
                </div>
              </div>
            </a>
          </div>
        `;
      }

      // Enhanced 3D effects with performance optimization
      function add3DEffects() {
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          return; // Skip 3D effects for users who prefer reduced motion
        }

        const cardContainers = document.querySelectorAll('.page-card-container');
        cardContainers.forEach(container => {
          const card = container.querySelector('.page-card');
          let isAnimating = false;
          
          const handleMouseMove = (e) => {
            if (isAnimating) return;
            isAnimating = true;
            
            requestAnimationFrame(() => {
              const rect = container.getBoundingClientRect();
              const centerX = rect.left + rect.width / 2;
              const centerY = rect.top + rect.height / 2;
              const mouseX = e.clientX - centerX;
              const mouseY = e.clientY - centerY;
              
              const rotateY = (mouseX / rect.width) * 15;
              const rotateX = -(mouseY / rect.height) * 15;
              
              card.style.transform = `rotateY(${rotateY}deg) rotateX(${rotateX}deg) scale(1.02)`;
              card.style.boxShadow = `${-rotateY*1.5}px ${rotateX*1.5}px 25px rgba(138,108,255,.25), 0 8px 25px rgba(0,0,0,.4)`;
              
              isAnimating = false;
            });
          };
          
          const handleMouseLeave = () => {
            requestAnimationFrame(() => {
              card.style.transform = 'rotateY(0deg) rotateX(0deg) scale(1)';
              card.style.boxShadow = '0 10px 30px rgba(0,0,0,.5)';
            });
          };
          
          container.addEventListener('mousemove', handleMouseMove);
          container.addEventListener('mouseleave', handleMouseLeave);
        });
      }

      // Sorting and filtering logic
      function sortPages(pages, sortBy) {
        const sorted = [...pages];
        
        switch (sortBy) {
          case 'newest':
            return sorted.sort((a, b) => b.metadata.addedDate - a.metadata.addedDate);
          case 'oldest':
            return sorted.sort((a, b) => a.metadata.addedDate - b.metadata.addedDate);
          case 'income-high':
            return sorted.sort((a, b) => {
              const aIncome = parseFloat(a.metadata.income.replace(/[^0-9.]/g, '')) || 0;
              const bIncome = parseFloat(b.metadata.income.replace(/[^0-9.]/g, '')) || 0;
              return bIncome - aIncome;
            });
          case 'income-low':
            return sorted.sort((a, b) => {
              const aIncome = parseFloat(a.metadata.income.replace(/[^0-9.]/g, '')) || 0;
              const bIncome = parseFloat(b.metadata.income.replace(/[^0-9.]/g, '')) || 0;
              return aIncome - bIncome;
            });
          case 'title':
            return sorted.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
          default:
            return sorted;
        }
      }

      function filterPages() {
        let filtered = [...allPages];
        
        // Search filter
        if (currentFilters.search) {
          const searchTerm = currentFilters.search.toLowerCase();
          filtered = filtered.filter(page => 
            page.metadata.title.toLowerCase().includes(searchTerm) ||
            page.metadata.description.toLowerCase().includes(searchTerm) ||
            page.metadata.category.toLowerCase().includes(searchTerm) ||
            page.metadata.subreddit.toLowerCase().includes(searchTerm)
          );
        }
        
        // Category filter
        if (currentFilters.category) {
          filtered = filtered.filter(page => page.metadata.category === currentFilters.category);
        }
        
        // Subreddit filter
        if (currentFilters.subreddit) {
          filtered = filtered.filter(page => page.metadata.subreddit === currentFilters.subreddit);
        }
        
        // Sort the filtered results
        filtered = sortPages(filtered, currentFilters.sort);
        
        filteredPages = filtered;
        updateStatsBar();
        renderFilteredPages();
      }

      function updateStatsBar() {
        resultsCount.textContent = `${filteredPages.length} result${filteredPages.length !== 1 ? 's' : ''}`;
        
        const activeFiltersList = [];
        if (currentFilters.search) activeFiltersList.push(`Search: "${currentFilters.search}"`);
        if (currentFilters.category) activeFiltersList.push(`Category: ${currentFilters.category}`);
        if (currentFilters.subreddit) activeFiltersList.push(`Subreddit: r/${currentFilters.subreddit}`);
        
        activeFilters.textContent = activeFiltersList.length > 0 ? 
          `Filters: ${activeFiltersList.join(', ')}` : '';
      }

      function populateFilterOptions() {
        // Get unique categories and subreddits
        const categories = [...new Set(allPages.map(p => p.metadata.category).filter(Boolean))];
        const subreddits = [...new Set(allPages.map(p => p.metadata.subreddit).filter(Boolean))];
        
        // Populate category filter
        categoryFilter.innerHTML = '<option value="">All Categories</option>';
        categories.sort().forEach(category => {
          const option = document.createElement('option');
          option.value = category;
          option.textContent = category.toUpperCase();
          categoryFilter.appendChild(option);
        });
        
        // Populate subreddit filter
        subredditFilter.innerHTML = '<option value="">All Subreddits</option>';
        subreddits.sort().forEach(subreddit => {
          const option = document.createElement('option');
          option.value = subreddit;
          option.textContent = `r/${subreddit}`;
          subredditFilter.appendChild(option);
        });
      }

      async function renderFilteredPages() {
        if (filteredPages.length === 0) {
          grid.innerHTML = `
            <div class="empty-state">
              <h3>No results found</h3>
              <p>Try adjusting your search terms or filters.</p>
            </div>
          `;
          return;
        }
        
        // Show skeleton cards first for better perceived performance
        const skeletons = Array(Math.min(filteredPages.length, 6)).fill(0).map(() => 
          '<div class="card-skeleton"></div>'
        ).join('');
        grid.innerHTML = skeletons;
        
        // Render cards in batches to avoid blocking the main thread
        const batchSize = 6;
        let renderedCards = [];
        
        for (let i = 0; i < filteredPages.length; i += batchSize) {
          const batch = filteredPages.slice(i, i + batchSize);
          const batchPromises = batch.map(page => createPageCard(page));
          
          try {
            const batchHTML = await Promise.all(batchPromises);
            renderedCards.push(...batchHTML);
            
            // Update grid with rendered cards so far
            grid.innerHTML = renderedCards.join('');
            
            // Add 3D effects to new cards
            if (i + batchSize >= filteredPages.length) {
              setTimeout(add3DEffects, 50);
            }
            
          } catch (err) {
            console.error('Error rendering card batch:', err);
          }
          
          // Yield to the main thread between batches
          if (i + batchSize < filteredPages.length) {
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
      }

      // Enhanced loading with metadata extraction
      async function loadPages() {
        syncButton.disabled = true;
        syncButton.textContent = 'Syncing...';
        grid.innerHTML = `
          <div class="text-center py-10 col-span-full">
            <div class="text-xl highlight mb-4">Syncing with Repository...</div>
            <div class="text-sm text-muted">Loading and analyzing content...</div>
          </div>
        `;

        try {
          // Fetch file list
          const response = await fetch(PAGES_DIR_API);
          if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status}`);
          }

          const files = await response.json();
          const htmlFiles = files.filter(f => f.type === 'file' && f.name.endsWith('.html'));
          
          // Process files with metadata extraction
          allPages = [];
          const concurrencyLimit = 4; // Limit concurrent fetches
          
          for (let i = 0; i < htmlFiles.length; i += concurrencyLimit) {
            const batch = htmlFiles.slice(i, i + concurrencyLimit);
            const batchPromises = batch.map(async (file) => {
              try {
                const pageUrl = `https://onqu3st.github.io/redditPages/html/${file.name}`;
                const contentResponse = await fetch(pageUrl);
                const htmlContent = contentResponse.ok ? await contentResponse.text() : '';
                
                return {
                  name: file.name,
                  metadata: extractMetadata(htmlContent, file.name)
                };
              } catch (err) {
                console.warn(`Failed to process ${file.name}:`, err);
                return {
                  name: file.name,
                  metadata: extractMetadata('', file.name)
                };
              }
            });
            
            const batchResults = await Promise.all(batchPromises);
            allPages.push(...batchResults);
            
            // Update progress
            const progress = Math.round(((i + batch.length) / htmlFiles.length) * 100);
            grid.innerHTML = `
              <div class="text-center py-10 col-span-full">
                <div class="text-xl highlight mb-4">Processing Content... ${progress}%</div>
                <div class="text-sm text-muted">Analyzing ${i + batch.length} of ${htmlFiles.length} pages</div>
              </div>
            `;
          }
          
          // Show filter bar and stats
          filterBar.style.display = 'flex';
          statsBar.style.display = 'flex';
          
          // Populate filter options
          populateFilterOptions();
          
          // Initial render
          filteredPages = [...allPages];
          await filterPages();
          
          pagesLoaded = true;
          
        } catch (err) {
          console.error('Failed to load pages:', err);
          grid.innerHTML = `
            <div class="text-center py-10 col-span-full text-red-400">
              <h3>Error Loading Content</h3>
              <p>${err.message}</p>
              <button onclick="location.reload()" class="sync-button mt-4">Retry</button>
            </div>
          `;
        } finally {
          syncButton.disabled = false;
          syncButton.textContent = 'Sync Sheets';
        }
      }

      // Event listeners
      syncButton.addEventListener('click', loadPages);
      
      searchInput.addEventListener('input', debounce((e) => {
        currentFilters.search = e.target.value;
        filterPages();
      }, 300));
      
      sortSelect.addEventListener('change', (e) => {
        currentFilters.sort = e.target.value;
        filterPages();
      });
      
      categoryFilter.addEventListener('change', (e) => {
        currentFilters.category = e.target.value;
        filterPages();
      });
      
      subredditFilter.addEventListener('change', (e) => {
        currentFilters.subreddit = e.target.value;
        filterPages();
      });
      
      clearFiltersBtn.addEventListener('click', () => {
        currentFilters = { search: '', sort: 'newest', category: '', subreddit: '' };
        searchInput.value = '';
        sortSelect.value = 'newest';
        categoryFilter.value = '';
        subredditFilter.value = '';
        filterPages();
      });
      
      // URL state management
      function updateURL() {
        const params = new URLSearchParams();
        if (currentFilters.search) params.set('search', currentFilters.search);
        if (currentFilters.sort !== 'newest') params.set('sort', currentFilters.sort);
        if (currentFilters.category) params.set('category', currentFilters.category);
        if (currentFilters.subreddit) params.set('subreddit', currentFilters.subreddit);
        
        const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
        window.history.replaceState({}, '', newURL);
      }
      
      function loadFromURL() {
        const params = new URLSearchParams(window.location.search);
        currentFilters.search = params.get('search') || '';
        currentFilters.sort = params.get('sort') || 'newest';
        currentFilters.category = params.get('category') || '';
        currentFilters.subreddit = params.get('subreddit') || '';
        
        searchInput.value = currentFilters.search;
        sortSelect.value = currentFilters.sort;
        categoryFilter.value = currentFilters.category;
        subredditFilter.value = currentFilters.subreddit;
      }
      
      // Load from URL on page load
      loadFromURL();
      
      // Update URL when filters change
      const originalFilterPages = filterPages;
      filterPages = function() {
        originalFilterPages();
        updateURL();
      };
    });
  </script>
</body>
</html>
